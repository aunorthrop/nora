<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Nora â€” voice-first team updates</title>
<style>
  :root{
    --bg:#0e0f13; --tile:#151821; --text:#e5e7ee; --muted:#9aa3b2;
    --lav:#a78bfa; --lav-ghost:#a78bfa26; --speak:#22c55e; --think:#facc15; --err:#ef4444;
  }
  html,body{height:100%}
  body{
    margin:0;background:var(--bg);color:var(--text);
    display:flex;align-items:center;justify-content:center;
    font-family:ui-sans-serif,system-ui,-apple-system,"Inter",Segoe UI,Roboto,Arial;
    -webkit-user-select:none;user-select:none;touch-action:manipulation
  }
  .mic{
    width:180px;height:180px;border-radius:24px;border:none;background:#1f2330;
    box-shadow:0 10px 40px #0006, inset 0 -2px 0 #000a;
    display:flex;align-items:center;justify-content:center;
    cursor:pointer; transition:transform .06s ease, background .15s ease, box-shadow .15s ease
  }
  .mic svg{width:42px;height:42px;fill:#e8ebf5;opacity:.95;pointer-events:none}
  .mic:active{transform:scale(.985)}
  .idle{background:#1f2330}
  .listening{background:var(--lav); box-shadow:0 0 0 10px var(--lav-ghost), 0 10px 40px #0008}
  .speaking{background:var(--speak)}
  .thinking{background:var(--think)}
  .error{background:var(--err)}

  .gate{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:#0009;z-index:40}
  .gate.visible{display:flex}
  .card{width:min(92vw,560px);background:#141824;border:1px solid #202334;border-radius:16px;padding:18px}
  .row{display:flex;gap:10px;margin-top:12px}
  .in{flex:1;background:#0f1220;border:1px solid #202334;border-radius:10px;color:#e5e7ee;padding:12px 14px;outline:none}
  .btn{padding:12px 14px;background:#334155;border:none;border-radius:10px;color:#e5e7ee;cursor:pointer}
  .toast{position:fixed;left:50%;bottom:14px;transform:translateX(-50%);
    background:#1f2330;color:#fff;padding:10px 14px;border-radius:10px;border:1px solid #2a2f44;
    box-shadow:0 8px 30px #0007;font-size:14px;z-index:50}
</style>
</head>
<body>

<!-- Team gate -->
<div id="gate" class="gate">
  <div class="card">
    <div style="font-weight:600">Enter team code</div>
    <div style="color:#9aa3b2;font-size:14px;margin-top:6px">Format: ####-####</div>
    <div class="row">
      <input id="teamCode" class="in" placeholder="1234-5678" inputmode="numeric" maxlength="9" autocomplete="one-time-code">
      <button id="enterBtn" class="btn" type="button">Enter</button>
    </div>
    <div style="margin-top:10px;color:#94a3b8;font-size:12px">Demo: <b>1234-5678</b></div>
  </div>
</div>

<!-- One mic button -->
<button id="mic" class="mic idle" type="button" aria-label="Toggle Nora">
  <svg viewBox="0 0 24 24"><path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c1.66 0 3 1.34 3 3zm7-3h-2a5 5 0 0 1-10 0H5a7 7 0 0 0 6 6.92V21h2v-3.08A7 7 0 0 0 19 11z"/></svg>
</button>

<script>
(()=> {
  const mic = document.getElementById('mic');
  const gate = document.getElementById('gate');
  const codeIn = document.getElementById('teamCode');
  const enterBtn = document.getElementById('enterBtn');

  const API='/.netlify/functions/voice';

  const LS_CODE='nora_team_code';
  const LS_ROLE='nora_role';
  const LS_INTRO='nora_intro_done_';

  const speaker=new Audio(); 
  speaker.preload='none'; 
  speaker.playsInline=true;
  speaker.crossOrigin = "anonymous";

  let audioCtx, primed=false, micPermissionGranted=false;
  let isOn=false, isSpeaking=false, loopRunning=false;
  let media=null, rec=null, chunks=[];
  let currentStream = null;

  function setState(s){ mic.className='mic '+s; }
  function toast(m){ 
    const t=document.createElement('div'); 
    t.className='toast'; 
    t.textContent=m; 
    document.body.appendChild(t); 
    setTimeout(()=>{t.remove();},3000); 
  }
  function showGate(){ gate.classList.add('visible'); }
  function hideGate(){ gate.classList.remove('visible'); }
  function normCode(s){ 
    const t=String(s||'').replace(/[^0-9]/g,'').slice(0,8); 
    return t.length===8? t.slice(0,4)+'-'+t.slice(4):''; 
  }

  // Initialize
  if(localStorage.getItem(LS_CODE)) {
    hideGate(); 
  } else {
    showGate();
  }

  // Team code entry
  enterBtn.onclick = ()=>{
    const c=normCode(codeIn.value)||codeIn.value.trim();
    if(!/^\d{4}-\d{4}$/.test(c)){ 
      toast('Use format: ####-####'); 
      return; 
    }
    localStorage.setItem(LS_CODE,c);
    localStorage.removeItem(LS_ROLE);
    hideGate();
    toast('Team code saved');
  };

  // Allow Enter key in team code input
  codeIn.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      enterBtn.click();
    }
  });

  // Audio context setup
  async function ensureAudio(){ 
    if(!audioCtx) {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    if(audioCtx.state !== 'running') {
      await audioCtx.resume();
    }
  }

  // Prime audio system
  async function primeAudioOnce(){
    if(primed) return;
    try {
      await ensureAudio();
      // Create silent audio buffer to wake up audio system
      const buffer = audioCtx.createBuffer(1, 1, audioCtx.sampleRate);
      const source = audioCtx.createBufferSource();
      source.buffer = buffer;
      source.connect(audioCtx.destination);
      source.start(0);
      
      // Prime speaker with silent audio
      speaker.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA=";
      const playPromise = speaker.play();
      if (playPromise !== undefined) {
        await playPromise.catch(() => {});
      }
      speaker.pause();
      speaker.currentTime = 0;
      
      primed = true;
    } catch(e) {
      console.warn('Audio priming failed:', e);
    }
  }

  // Request microphone permission
  async function requestMicPermission(){
    if(micPermissionGranted) return true;
    
    try {
      // Clean up any existing stream first
      if(currentStream) {
        currentStream.getTracks().forEach(track => track.stop());
        currentStream = null;
      }

      const stream = await navigator.mediaDevices.getUserMedia({
        audio: {
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true,
          sampleRate: 16000
        }
      });
      
      // Test that we can actually use the stream
      currentStream = stream;
      micPermissionGranted = true;
      
      // Don't stop the stream immediately - keep it for use
      return true;
    } catch(e) {
      console.error('Microphone permission denied:', e);
      toast('Microphone permission required');
      return false;
    }
  }

  // Play audio from data URL
  async function playDataUrl(url){
    if (!url) return;
    
    isSpeaking = true; 
    setState('speaking');
    
    try {
      speaker.pause();
      speaker.currentTime = 0;
      speaker.src = url;
      
      const playPromise = speaker.play();
      if (playPromise !== undefined) {
        await playPromise;
        // Wait for audio to finish
        await new Promise(resolve => {
          const checkEnded = () => {
            if (speaker.ended || speaker.paused) {
              resolve();
            } else {
              setTimeout(checkEnded, 100);
            }
          };
          speaker.onended = resolve;
          speaker.onerror = resolve;
          checkEnded();
        });
      }
    } catch(e) {
      console.error('Audio playback error:', e);
    } finally {
      isSpeaking = false;
      setState(isOn ? 'listening' : 'idle');
    }
  }

  // Get best MIME type for recording
  function getRecordingMimeType(){ 
    const MediaRecorder = window.MediaRecorder;
    if(!MediaRecorder || !MediaRecorder.isTypeSupported) return "";
    
    const preferred = [
      "audio/webm;codecs=opus",
      "audio/webm", 
      "audio/mp4;codecs=mp4a.40.2",
      "audio/m4a",
      "audio/mpeg",
      "audio/wav"
    ];
    
    for(const mime of preferred) {
      if(MediaRecorder.isTypeSupported(mime)) return mime;
    }
    return "";
  }

  // Start recording
  async function startRecording(){
    try {
      // Use existing stream if available, otherwise request new one
      if (!currentStream || !currentStream.active) {
        const hasPermission = await requestMicPermission();
        if (!hasPermission) {
          throw new Error('Microphone permission denied');
        }
      }

      const mimeType = getRecordingMimeType();
      const options = mimeType ? { mimeType } : {};
      
      rec = new MediaRecorder(currentStream, options);
      chunks = [];
      
      rec.ondataavailable = e => {
        if (e.data && e.data.size > 0) {
          chunks.push(e.data);
        }
      };
      
      rec.start(200); // Collect data every 200ms
      return rec;
    } catch(e) {
      console.error('Failed to start recording:', e);
      throw e;
    }
  }

  // Stop recording
  function stopRecording(){ 
    try {
      if (rec && rec.state !== 'inactive') {
        rec.stop();
      }
    } catch(e) {
      console.error('Error stopping recorder:', e);
    }
    rec = null;
  }

  // Wait for user to finish speaking
  function waitForUtterance(recorder){
    const MIN_BYTES = 800;      // Minimum audio data size
    const SILENCE_TIMEOUT = 1200;  // Time to wait after last audio data
    const MAX_RECORDING_TIME = 15000; // Maximum recording time
    
    return new Promise(resolve => {
      let startTime = performance.now();
      let lastDataTime = startTime;
      let hasAudioData = false;
      
      const checkInterval = setInterval(() => {
        const now = performance.now();
        
        // Check if we have new audio data
        if (chunks.length > 0) {
          hasAudioData = true;
          lastDataTime = now;
        }
        
        // Stop if we have audio data and haven't received new data for a while
        if (hasAudioData && (now - lastDataTime) > SILENCE_TIMEOUT) {
          clearInterval(checkInterval);
          try {
            recorder.stop();
          } catch(e) {}
          
          setTimeout(() => {
            const blob = new Blob(chunks, { type: recorder.mimeType || 'audio/webm' });
            chunks = [];
            resolve(blob.size > MIN_BYTES ? blob : null);
          }, 200);
          return;
        }
        
        // Stop if maximum recording time reached
        if (now - startTime > MAX_RECORDING_TIME) {
          clearInterval(checkInterval);
          try {
            recorder.stop();
          } catch(e) {}
          
          setTimeout(() => {
            const blob = new Blob(chunks, { type: recorder.mimeType || 'audio/webm' });
            chunks = [];
            resolve(blob.size > MIN_BYTES ? blob : null);
          }, 200);
        }
      }, 150);
    });
  }

  // Convert blob to base64
  async function blobToBase64(blob){ 
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => {
        const base64 = reader.result.split(',')[1];
        resolve(base64);
      };
      reader.onerror = () => reject(reader.error);
      reader.readAsDataURL(blob);
    });
  }

  // Server acknowledgment fallback
  async function serverAck(text){
    try {
      const code = localStorage.getItem(LS_CODE) || '';
      const response = await fetch(API, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ businessId: code, say: text })
      });
      
      if (!response.ok) throw new Error(`Server error: ${response.status}`);
      
      const data = await response.json();
      if (data.audio) {
        await playDataUrl(data.audio);
      }
    } catch(e) {
      console.error('Server ack failed:', e);
    }
  }

  // Main conversation loop
  async function conversationLoop(){
    if(loopRunning) return;
    loopRunning = true;
    
    while(isOn){
      try {
        // Skip if currently speaking
        if(isSpeaking){ 
          await new Promise(resolve => setTimeout(resolve, 100)); 
          continue; 
        }

        await ensureAudio();
        const recorder = await startRecording();
        const audioBlob = await waitForUtterance(recorder);
        stopRecording();
        
        if(!isOn) break; // Check if turned off during recording
        
        if(!audioBlob) continue; // No audio detected, continue listening

        const code = localStorage.getItem(LS_CODE) || '';
        const role = localStorage.getItem(LS_ROLE) || 'employee';
        const audioBase64 = await blobToBase64(audioBlob);
        
        setState('thinking');
        
        const response = await fetch(API, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            businessId: code,
            audio: { 
              data: audioBase64, 
              mime: audioBlob.type 
            },
            role: role
          })
        });

        if (!response.ok) {
          throw new Error(`Server error: ${response.status}`);
        }

        const data = await response.json();

        // Handle server responses
        if (data.control?.requireCode) { 
          isOn = false; 
          setState('idle'); 
          showGate(); 
          toast('Team code required');
          break; 
        }
        
        if (data.control?.role) { 
          localStorage.setItem(LS_ROLE, data.control.role); 
        }

        // Play response audio
        if (data.audio) {
          await playDataUrl(data.audio);
        } else if (data.response) {
          // Fallback: convert text response to audio
          const ttsResponse = await fetch(API, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ businessId: code, say: data.response })
          });
          
          if (ttsResponse.ok) {
            const ttsData = await ttsResponse.json();
            if (ttsData.audio) {
              await playDataUrl(ttsData.audio);
            }
          }
        } else {
          // Last resort acknowledgment
          await serverAck("I heard you.");
        }
        
        setState('listening');

      } catch(e) {
        console.error('Conversation loop error:', e);
        await serverAck("Sorry, I had trouble with that.");
        setState('error');
        setTimeout(() => setState(isOn ? 'listening' : 'idle'), 500);
      }
    }
    loopRunning = false;
  }

  // Main mic button handler
  mic.addEventListener('click', async () => {
    // Check for team code
    if(!localStorage.getItem(LS_CODE)){ 
      showGate(); 
      return; 
    }
    
    // Stop speaking if currently playing audio
    if(isSpeaking){ 
      try {
        speaker.pause();
        speaker.currentTime = 0;
      } catch(e) {}
      return; 
    }
    
    if(!isOn){
      // Turn ON
      isOn = true; 
      mic.setAttribute('aria-pressed', 'true');
      setState('thinking');
      
      try { 
        await primeAudioOnce(); 
        const hasPermission = await requestMicPermission();
        
        if (!hasPermission) {
          throw new Error('Microphone permission required');
        }

        // Handle intro for first-time users
        const code = localStorage.getItem(LS_CODE);
        const introKey = LS_INTRO + code;
        
        if (!localStorage.getItem(introKey)) {
          // First time user - get intro
          const response = await fetch(API, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ businessId: code, intro: true })
          });
          
          if (response.ok) {
            const data = await response.json();
            if (data.audio) {
              await playDataUrl(data.audio);
            } else if (data.response) {
              await serverAck(data.response);
            }
          }
          
          localStorage.setItem(introKey, '1');
        } else {
          // Returning user - check for updates
          const response = await fetch(API, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ 
              businessId: code, 
              checkUpdates: true,
              role: localStorage.getItem(LS_ROLE) || 'employee'
            })
          });
          
          if (response.ok) {
            const data = await response.json();
            if (data.audio) {
              await playDataUrl(data.audio);
            } else if (data.response) {
              await serverAck(data.response);
            }
          }
        }
        
        setState('listening');
        conversationLoop();
        
      } catch(e) { 
        console.error('Failed to start Nora:', e);
        isOn = false; 
        mic.setAttribute('aria-pressed', 'false'); 
        setState('error'); 
        toast('Failed to start - check microphone permissions');
        setTimeout(() => setState('idle'), 1000);
      }
      
    } else {
      // Turn OFF
      isOn = false; 
      mic.setAttribute('aria-pressed', 'false'); 
      setState('idle'); 
      stopRecording();
      
      // Clean up stream
      if (currentStream) {
        currentStream.getTracks().forEach(track => track.stop());
        currentStream = null;
        micPermissionGranted = false;
      }
    }
  });

  // Format team code input
  codeIn.addEventListener('input', (e) => {
    const formatted = normCode(e.target.value);
    if (formatted && formatted !== e.target.value) {
      e.target.value = formatted;
    }
  });

})();
</script>
</body>
</html>
