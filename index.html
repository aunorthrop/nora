<!-- only the <script> block changed; keep your existing HTML/CSS above -->
<script>
(() => {
  const DEMO_CODE = 'TEAM-NORA';
  const STORAGE_KEY = 'nora_business_code';
  const ADMIN_ARM_KEY = 'nora_admin_armed';

  function getBiz(){ return localStorage.getItem(STORAGE_KEY) || ""; }
  function setBiz(v){ localStorage.setItem(STORAGE_KEY, String(v||"").trim()); }
  function isAdminArmed(){ return localStorage.getItem(ADMIN_ARM_KEY) === '1'; }
  function armAdmin(){ localStorage.setItem(ADMIN_ARM_KEY, '1'); }
  function disarmAdmin(){ localStorage.removeItem(ADMIN_ARM_KEY); }

  // (If you still want the demo code auto-set, leave this line ON.
  //  If you want to force real codes only, comment it out.)
  if (!getBiz()) { setBiz(DEMO_CODE); }

  const voiceBtn = document.getElementById('voiceBtn');
  const openUpload = document.getElementById('openUpload');
  const uploadModal = document.getElementById('uploadModal');
  const closeUpload = document.getElementById('closeUpload');
  const fileInput = document.getElementById('fileInput');
  const uploadArea = document.getElementById('uploadArea');
  const fileList = document.getElementById('fileList');

  const codeModal = document.getElementById('codeModal');
  const teamCodeInput = document.getElementById('teamCode');
  const saveCodeBtn = document.getElementById('saveCode');
  const closeCodeBtn = document.getElementById('closeCode');

  function showModal(m){ m.classList.add('open'); m.setAttribute('aria-hidden','false'); }
  function hideModal(m){ m.classList.remove('open'); m.setAttribute('aria-hidden','true'); }

  saveCodeBtn.addEventListener('click', () => { const v = teamCodeInput.value.trim(); if (!v) return; setBiz(v); hideModal(codeModal); });
  closeCodeBtn.addEventListener('click', () => hideModal(codeModal));

  // Long-press mic => open code modal
  let pressTimer;
  function startPress(){ clearTimeout(pressTimer); pressTimer = setTimeout(()=>{ teamCodeInput.value = getBiz(); showModal(codeModal); }, 1200); }
  function cancelPress(){ clearTimeout(pressTimer); }
  voiceBtn.addEventListener('touchstart', startPress, {passive:true});
  voiceBtn.addEventListener('mousedown', startPress);
  voiceBtn.addEventListener('touchend', cancelPress);
  voiceBtn.addEventListener('mouseup', cancelPress);

  // Upload modal
  openUpload.addEventListener('click', () => { if (!getBiz()) { teamCodeInput.value = ""; showModal(codeModal); return; } showModal(uploadModal); renderFileList(); });
  closeUpload.addEventListener('click', () => hideModal(uploadModal));

  // Audio session
  let isSession=false,isListening=false,isProcessing=false,isSpeaking=false;
  let audioCtx, micStream, recorder, chunks=[];
  let inflight, sessionId=null;
  const speaker = new Audio(); speaker.preload="none"; speaker.playsInline=true;

  function setState(cls){
    voiceBtn.className = `voice-button ${cls}`;
    const map = {
      idle:'Press to talk', listening:'Listening — tap to stop', thinking:'Working…',
      speaking:'Speaking — tap to interrupt', error:'Error — tap to retry'
    };
    voiceBtn.setAttribute('aria-label', map[cls] || 'Press to talk');
  }

  async function ensureAudio(){
    if (!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    if (audioCtx.state !== 'running') await audioCtx.resume();
  }
  function getPreferredMime(){
    const isiOS=/iPad|iPhone|iPod/.test(navigator.userAgent);
    const isSafari=/Safari/.test(navigator.userAgent)&&!/Chrome/.test(navigator.userAgent);
    if(isiOS||isSafari){
      if(MediaRecorder.isTypeSupported("audio/mp4;codecs=mp4a.40.2")) return "audio/mp4;codecs=mp4a.40.2";
      if(MediaRecorder.isTypeSupported("audio/mp4")) return "audio/mp4";
    } else {
      if(MediaRecorder.isTypeSupported("audio/webm;codecs=opus")) return "audio/webm;codecs=opus";
      if(MediaRecorder.isTypeSupported("audio/webm")) return "audio/webm";
    }
    return "";
  }

  async function startListening(){
    if (isListening || isProcessing) return;
    isListening = true; setState('listening');
    await ensureAudio();

    micStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation:true, noiseSuppression:true, autoGainControl:true }, video:false });
    const mime = getPreferredMime(); const opts={}; if(mime) opts.mimeType=mime;
    recorder = new MediaRecorder(micStream, opts);
    chunks=[]; recorder.ondataavailable = (e)=>{ if(e.data && e.data.size>0) chunks.push(e.data); };
    recorder.onstop = processRecording;
    recorder.start(120);
  }
  function stopListening(){
    try{ if(recorder && recorder.state==='recording') recorder.stop(); }catch{}
    try{ micStream?.getTracks().forEach(t=>t.stop()); }catch{}
    isListening=false;
  }

  async function processRecording(){
    isListening=false; isProcessing=true; setState('thinking');
    try{
      const blob = new Blob(chunks,{ type:recorder?.mimeType||'audio/webm' }); chunks=[];
      if (!blob.size) { isProcessing=false; setState('idle'); return; }
      const b64 = await blobToBase64(blob);
      inflight?.abort(); inflight = new AbortController();

      const payload = {
        businessId: getBiz(),
        sessionId,
        mode: isAdminArmed() ? 'admin-armed' : 'normal',
        audio: { data: b64, mime: blob.type }
      };

      const resp = await fetch('/.netlify/functions/voice',{
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify(payload),
        signal: inflight.signal
      });
      const data = await resp.json();
      sessionId = data.sessionId || sessionId;

      // React to control signals
      if (data.control?.adminArmed) armAdmin();
      if (data.control?.adminDisarm) disarmAdmin();
      if (data.control?.requireCode) { teamCodeInput.value = ""; showModal(codeModal); }

      if (data.audio){
        await play(data.audio);
      } else {
        setState('idle');
      }

      isProcessing=false;
      if (isSession) startListening();
    }catch(e){
      isProcessing=false;
      setState('error');
      console.log(e);
    }
  }

  async function play(dataUrl){
    try{
      isSpeaking=true; setState('speaking');
      speaker.src = dataUrl; await speaker.play();
      await new Promise(r => speaker.onended=r);
      isSpeaking=false; setState('idle');
    }catch{ isSpeaking=false; setState('error'); }
  }

  function blobToBase64(blob){
    return new Promise((res,rej)=>{ const r=new FileReader(); r.onloadend=()=>res(String(r.result).split(",")[1]||""); r.onerror=()=>rej(r.error||new Error("readAsDataURL failed")); r.readAsDataURL(blob); });
  }

  async function runBriefThenListen(){
    try{
      setState('thinking');
      const r = await fetch('/.netlify/functions/brief',{ method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({ businessId:getBiz() }) });
      const j = await r.json();
      if (j.audio) await play(j.audio);
      await startListening();
    }catch{ await startListening(); }
  }

  // Toggle mic
  voiceBtn.addEventListener('click', async (e)=>{
    e.preventDefault();
    if (!getBiz()) { teamCodeInput.value = ""; showModal(codeModal); return; }
    if (!isSession){
      isSession = true;
      sessionId = `sess_${Date.now()}`;
      runBriefThenListen();
    } else {
      if (isSpeaking) { try{ speaker.pause(); speaker.currentTime=0; }catch{} isSpeaking=false; }
      stopListening(); isSession=false; setState('idle');
    }
  });

  // Uploads (unchanged)
  const fileInputEl = document.getElementById('fileInput');
  fileInputEl.addEventListener('change', async () => {
    const files = Array.from(fileInputEl.files || []);
    if (!files.length) return;
    for (const file of files){
      if (file.size > 10 * 1024 * 1024) { showProgress(file.name, "Too large (max 10MB)", 0, true); continue; }
      const slot = showProgress(file.name, "Reading…", 0);
      try{
        const { text } = await extractText(file, (p)=>updateProgress(slot, p));
        updateProgress(slot, 70, "Uploading…");
        await uploadDoc(file.name, file.size, text);
        updateProgress(slot, 100, "Completed", true);
      }catch(err){
        updateProgress(slot, 0, "Failed", true, true);
        console.log(err);
      }
    }
    await renderFileList();
    fileInputEl.value = "";
  });

  async function extractText(file, onProg){
    const ext = (file.name.split('.').pop()||"").toLowerCase();
    if (ext === "pdf"){
      onProg(10);
      const buf = await file.arrayBuffer(); onProg(20);
      const pdf = await pdfjsLib.getDocument({ data: buf }).promise; onProg(30);
      let text = "";
      for (let i=1;i<=pdf.numPages;i++){
        const page = await pdf.getPage(i);
        const cnt = await page.getTextContent();
        text += cnt.items.map(it => it.str).join(" ") + "\n";
        onProg(30 + Math.floor((i/pdf.numPages)*40));
      }
      return { text };
    } else {
      const t = await file.text();
      onProg(60);
      return { text: t };
    }
  }
  function showProgress(name, label, pct=0, done=false, error=false){
    const wrap = document.createElement('div');
    wrap.className = 'item';
    wrap.innerHTML = `
      <div class="meta">${escapeHtml(name)}</div>
      <div style="flex:1;margin-left:10px">
        <div class="bar"><div class="fill" style="width:${pct}%"></div></div>
        <div class="meta">${label}${done ? (error ? '' : ' <span class="chk">✔</span>') : ''}</div>
      </div>`;
    uploadArea.prepend(wrap);
    return wrap;
  }
  function updateProgress(slot, pct, label, done=false){
    const fill = slot.querySelector('.fill');
    if (fill) fill.style.width = `${pct}%`;
    const metas = slot.querySelectorAll('.meta');
    const meta = metas[metas.length-1];
    if (meta && label) meta.innerHTML = `${label}${done ? ' <span class="chk">✔</span>' : ''}`;
  }
  async function uploadDoc(name, size, text){
    const r = await fetch('/.netlify/functions/files',{
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ businessId:getBiz(), name, size, text })
    });
    if (!r.ok) throw new Error('upload failed');
    return r.json();
  }
  async function renderFileList(){
    const r = await fetch('/.netlify/functions/files?businessId=' + encodeURIComponent(getBiz()));
    const j = await r.json();
    const docs = j.docs || [];
    fileList.innerHTML = docs.length
      ? docs.map(d => `
        <div class="item">
          <div class="meta">${escapeHtml(d.name)} <span style="opacity:.6;font-size:12px">(${Math.round(d.size/1024)} KB)</span></div>
          <button class="btn" data-id="${d.id}">Remove</button>
        </div>`).join('')
      : '<div class="meta" style="opacity:.75">No files uploaded yet.</div>';
    fileList.querySelectorAll('button[data-id]').forEach(btn=>{
      btn.onclick = async () => {
        await fetch('/.netlify/functions/files?businessId='+encodeURIComponent(getBiz())+'&id='+encodeURIComponent(btn.dataset.id), { method:'DELETE' });
        renderFileList();
      };
    });
  }
  function escapeHtml(s){ return String(s||"").replace(/[&<>"']/g, m=>({ "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;" }[m])); }
})();
</script>
