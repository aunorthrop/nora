<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Nora — voice-first team updates</title>
<style>
  :root{ --bg:#0e0f13; --tile:#151821; --text:#e5e7ee; --muted:#9aa3b2;
         --lav:#a78bfa; --lav-ghost:#a78bfa26; --speak:#22c55e; --think:#facc15; --err:#ef4444; }
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--text);display:flex;align-items:center;justify-content:center;
       font-family:ui-sans-serif,system-ui,-apple-system,"Inter",Segoe UI,Roboto,Arial; -webkit-user-select:none;user-select:none;touch-action:manipulation}
  .mic{width:180px;height:180px;border-radius:24px;border:none;background:#1f2330;
       box-shadow:0 10px 40px #0006, inset 0 -2px 0 #000a;display:flex;align-items:center;justify-content:center;
       cursor:pointer;transition:transform .06s ease, background .15s ease, box-shadow .15s ease}
  .mic svg{width:42px;height:42px;fill:#e8ebf5;opacity:.95;pointer-events:none}
  .mic:active{transform:scale(.985)}
  .idle{background:#1f2330}
  .listening{background:var(--lav); box-shadow:0 0 0 10px var(--lav-ghost), 0 10px 40px #0008}
  .speaking{background:var(--speak)}
  .thinking{background:var(--think)}
  .error{background:var(--err)}

  /* Team gate */
  .gate{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:#0009;z-index:40}
  .gate.visible{display:flex}
  .card{width:min(92vw,560px);background:#141824;border:1px solid #202334;border-radius:16px;padding:18px}
  .row{display:flex;gap:10px;margin-top:12px}
  .in{flex:1;background:#0f1220;border:1px solid #202334;border-radius:10px;color:#e5e7ee;padding:12px 14px;outline:none}
  .btn{padding:12px 14px;background:#334155;border:none;border-radius:10px;color:#e5e7ee;cursor:pointer}
  .btn.primary{background:#2563eb}

  .toast{position:fixed;left:50%;bottom:14px;transform:translateX(-50%);
    background:#1f2330;color:#fff;padding:10px 14px;border-radius:10px;border:1px solid #2a2f44;
    box-shadow:0 8px 30px #0007;font-size:14px;z-index:50}
</style>
</head>
<body>

<!-- Gate -->
<div id="gate" class="gate">
  <div class="card">
    <div style="font-weight:600">Enter team code</div>
    <div style="color:#9aa3b2;font-size:14px;margin-top:6px">Format: ####-####</div>
    <div class="row">
      <input id="teamCode" class="in" placeholder="1234-5678" inputmode="numeric" maxlength="9" autocomplete="one-time-code">
      <button id="enterBtn" class="btn" type="button">Enter</button>
    </div>
    <div style="margin-top:10px;color:#94a3b8;font-size:12px">Demo: <b>1234-5678</b></div>
  </div>
</div>

<!-- Mic -->
<button id="mic" class="mic idle" type="button" aria-label="Toggle Nora">
  <svg viewBox="0 0 24 24"><path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c1.66 0 3 1.34 3 3zm7-3h-2a5 5 0 0 1-10 0H5a7 7 0 0 0 6 6.92V21h2v-3.08A7 7 0 0 0 19 11z"/></svg>
</button>

<script>
(()=> {
  // DOM
  const mic = document.getElementById('mic');
  const gate = document.getElementById('gate');
  const codeIn = document.getElementById('teamCode');
  const enterBtn = document.getElementById('enterBtn');

  // Endpoints
  const API_VOICE='/.netlify/functions/voice';

  // Storage keys
  const LS_CODE='nora_team_code';
  const LS_ROLE='nora_role';
  const LS_INTRO_PREFIX='nora_intro_done_';

  // Intro text (guaranteed spoken via fallback on first tap)
  const INTRO_TEXT = "Hi, I’m Nora. I’m on. If you’re the owner, say admin and tell me the updates—I'll remember them. Team members can ask what’s new or anything we’ve saved. Tap again to turn me off.";

  // Audio
  const speaker=new Audio(); speaker.preload='none'; speaker.playsInline=true;

  // State
  let audioCtx, isOn=false, isSpeaking=false, inflight=null;
  let rec=null, media=null, chunks=[];
  let loopRunning=false, micPrimed=false, primed=false;

  // Helpers
  function toast(m){ const t=document.createElement('div'); t.className='toast'; t.textContent=m; document.body.appendChild(t); setTimeout(()=>{try{t.remove();}catch{}},2600); }
  function setState(s){ mic.className='mic '+s; }
  function showGate(){ gate.classList.add('visible'); }
  function hideGate(){ gate.classList.remove('visible'); }
  function normCode(s){ const t=String(s||'').replace(/[^0-9]/g,'').slice(0,8); return t.length===8? t.slice(0,4)+'-'+t.slice(4):''; }

  // Gate init
  if(localStorage.getItem(LS_CODE)) hideGate(); else showGate();
  enterBtn.onclick = ()=> {
    const c=normCode(codeIn.value)||codeIn.value.trim();
    if(!/^\d{4}-\d{4}$/.test(c)){ toast('Use ####-####'); return; }
    localStorage.setItem(LS_CODE,c);
    localStorage.removeItem(LS_ROLE);
    hideGate();
  };

  // Audio boot
  async function ensureAudio(){ if(!audioCtx) audioCtx=new (window.AudioContext||window.webkitAudioContext)(); if(audioCtx.state!=='running') await audioCtx.resume(); }
  async function primeOnce(){
    if(primed) return;
    await ensureAudio();
    // unlock autoplay for iOS (WebAudio + HTMLAudio)
    const b=audioCtx.createBuffer(1,1,audioCtx.sampleRate);
    const s=audioCtx.createBufferSource(); s.buffer=b; s.connect(audioCtx.destination); s.start(0);
    try{ speaker.src="data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA="; await speaker.play(); speaker.pause(); speaker.currentTime=0; }catch{}
    primed=true;
  }
  async function askMicPermissionOnce(){
    if(micPrimed) return;
    const t = await navigator.mediaDevices.getUserMedia({audio:{echoCancellation:true,noiseSuppression:true,autoGainControl:true}});
    t.getTracks().forEach(x=>x.stop());
    micPrimed=true;
  }

  // Guaranteed speech fallback
  async function speakFallback(text){
    try{
      if(!('speechSynthesis' in window)) return false;
      const u=new SpeechSynthesisUtterance(String(text||""));
      u.rate=0.98; u.pitch=1.05; u.volume=1.0;
      return await new Promise(res=>{ u.onend=()=>res(true); u.onerror=()=>res(false); window.speechSynthesis.cancel(); window.speechSynthesis.speak(u); });
    }catch{ return false; }
  }

  // Play server audio or fallback text
  async function playAudioOrText(dataUrl, fallbackText){
    isSpeaking=true; setState('speaking');
    try{
      if(dataUrl){
        speaker.pause(); speaker.currentTime=0; speaker.src=dataUrl;
        await speaker.play();
        await new Promise(res=>{ speaker.onended=res; speaker.onpause=res; });
      }else{
        await speakFallback(fallbackText || "Okay.");
      }
    }catch{
      await speakFallback(fallbackText || "Okay.");
    }
    isSpeaking=false; setState(isOn?'listening':'idle');
  }

  function abortInFlight(){ try{ inflight?.abort(); }catch{} inflight=null; }
  function stopRecorder(){ try{rec?.stop();}catch{} try{media?.getTracks().forEach(t=>t.stop());}catch{} rec=null; media=null; }

  // Recorder
  function pickMime(){ const M=window.MediaRecorder; if(!M||!M.isTypeSupported) return ""; const pref=["audio/mp4;codecs=mp4a.40.2","audio/m4a","audio/webm;codecs=opus","audio/webm","audio/mpeg","audio/wav"]; for(const m of pref) if(M.isTypeSupported(m)) return m; return ""; }
  async function startRecorder(){
    const mime=pickMime();
    media=await navigator.mediaDevices.getUserMedia({audio:{echoCancellation:true,noiseSuppression:true,autoGainControl:true}});
    rec=new MediaRecorder(media,mime?{mimeType:mime}:{});
    chunks=[]; rec.ondataavailable=e=>{ if(e.data&&e.data.size) chunks.push(e.data); };
    rec.start(150); return rec;
  }
  function waitUtterance(r){
    return new Promise(resolve=>{
      let start=performance.now(), last=start, heard=false;
      const iv=setInterval(()=>{
        const now=performance.now();
        if(chunks.length){ heard=true; last=now; }
        if(heard && now-last>1100){
          clearInterval(iv); try{r.stop();}catch{} setTimeout(()=>{
            const b=new Blob(chunks,{type:r.mimeType||'audio/webm'}); chunks=[]; resolve(b.size>1400?b:null);
          },140);
        }
        if(now-start>14000){ clearInterval(iv); try{r.stop();}catch{} resolve(null); }
      },120);
    });
  }
  async function blobToB64(b){ return new Promise((res,rej)=>{ const fr=new FileReader(); fr.onloadend=()=>res(String(fr.result).split(',')[1]); fr.onerror=()=>rej(fr.error); fr.readAsDataURL(b); }); }

  // Fetch with timeout
  async function fetchJSONWithTimeout(url, options={}, ms=12000){
    const ctrl=new AbortController(); const t=setTimeout(()=>ctrl.abort(), ms);
    try{
      const r=await fetch(url,{...options, signal:ctrl.signal});
      const j=await r.json().catch(()=>({}));
      return {ok:r.ok, status:r.status, json:j};
    }finally{ clearTimeout(t); }
  }

  // Listen loop (single-run guard)
  let loopRunning=false;
  async function listenLoop(){
    if(loopRunning) return; loopRunning=true;
    while(isOn){
      try{
        if(isSpeaking){ await new Promise(r=>setTimeout(r,60)); continue; }
        await ensureAudio();
        const r=await startRecorder();
        const heard=await waitUtterance(r);
        stopRecorder();
        if(!isOn) break;
        if(!heard) continue;

        const b64=await blobToB64(heard);
        const code=localStorage.getItem(LS_CODE)||'';
        const role=localStorage.getItem(LS_ROLE)||'employee';

        setState('thinking');
        const {ok,status,json} = await fetchJSONWithTimeout(API_VOICE,{
          method:'POST',headers:{'Content-Type':'application/json'},
          body:JSON.stringify({businessId:code,audio:{data:b64,mime:heard.type},role})
        });

        if(json.control?.requireCode){ isOn=false; setState('idle'); showGate(); toast('Enter your team code'); break; }
        if(json.control?.role){ localStorage.setItem(LS_ROLE, json.control.role); }

        if(ok){
          await playAudioOrText(json.audio || null, json.response || json.text || "Okay.");
        }else{
          toast(`Server ${status||'error'}`); // still talk so it's never silent
          await playAudioOrText(null, "I ran into an error, but I heard you.");
        }

      }catch(e){
        setState('error'); toast(String(e.message||'error')); await new Promise(r=>setTimeout(r,250)); setState(isOn?'listening':'idle');
      }
    }
    loopRunning=false;
  }

  // Toggle
  mic.addEventListener('click', async ()=>{
    if(isSpeaking){ try{speaker.pause();}catch{} return; } // interrupt

    if(!localStorage.getItem(LS_CODE)){ showGate(); return; }

    if(!isOn){
      isOn=true; mic.setAttribute('aria-pressed','true');

      try{ await primeOnce(); await askMicPermissionOnce(); }
      catch(e){ isOn=false; mic.setAttribute('aria-pressed','false'); setState('error'); toast('Microphone permission is required'); return; }

      // INTRO once (guaranteed via fallback)
      const code=localStorage.getItem(LS_CODE);
      const introKey=LS_INTRO_PREFIX+code;
      if(!localStorage.getItem(introKey)){
        setState('speaking');
        // speak immediately so the user hears something right now
        await speakFallback(INTRO_TEXT);
        localStorage.setItem(introKey,'1');
        // (optional) warm the function but ignore result
        fetch(API_VOICE,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({businessId:code,intro:true})}).catch(()=>{});
      }

      setState('listening');
      listenLoop();
    } else {
      isOn=false; mic.setAttribute('aria-pressed','false');
      abortInFlight(); stopRecorder(); setState('idle');
    }
  });

  // Errors → on-screen
  window.addEventListener('error', e=> toast(e.message||'error'));
  window.addEventListener('unhandledrejection', e=> { const m=String(e.reason||''); if(!/AbortError/i.test(m)) toast(m); });
})();
</script>
</body>
</html>
